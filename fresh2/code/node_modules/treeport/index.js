var View = require("view42/v1");
var Mod = require("mod42/v1a");

var Tabs = View.extend({
	name: "Tabs"
});

var Panel = Mod.extend({
	name: "Panel",

});

var Tab = View.extend({
	name: "Tab",
	render: function(){
		this.append(this.name).click(function(){
			this.panel.activate();
		}.bind(this));
	}
});

var Panels = module.exports = View.extend({
	name: "Panels",
	// log: true,
	Tab: Tab,
	Tabs: Tabs,
	Container: View.extend({name: "Container"}),
	instantiate: function(){
		this.panels = [];
		View.prototype.instantiate.apply(this, arguments);
	},
	// initialize: function(){
	// 	this.render();
	// 	this.update();
	// 	this.panels.forEach(function(panel){
	// 		panel.view.hide();
	// 	});
	// 	this.active = this.panels[0].view.show();
	// },
	instantiate_el: function(){
		View.prototype.instantiate_el.apply(this, arguments);

		// this is like... prerender..?
		// render these before .set, so we can auto append panels
		this.append({
			tabs: this.Tabs(),
			container: this.Container()
		});
	},
	_set_prop$: function(value, name){
		// prototypes don't have .el, but we still might want to add a prototype.subView
		if (this.el && (value instanceof View)){
			this.append_panel(value, name);
			// return true to indicate that we've handled this property
			return true;
		}

		// return false to do standard set procedure
		return false;
	},
	append_panel: function(view, name){
		name = name || view.name;

		view.panels = this;

		// maybe make "container" a switchable thing?  .container == self, or can be set to another?
		this.container.append_view(view, name);

		var tab = this.Tab({
			name: name,
			view: view,
			panels: this
		});

		var panel = {
			tab: tab,
			view: view,
			// naming "panels" (the Panels instance) and panels.panels (the array) the same thing is really confusing...
			panels: this,
			activate: function(){
				if (this.panels.active)
					this.panels.active.deactivate();
				this.view.show();
				this.view.addClass("active");
				this.tab.addClass("active");
				this.panels.active = this;
			},
			deactivate: function(){
				this.view.removeClass("active");
				this.tab.removeClass("active");
				this.view.hide();
			}
		};

		tab.panel = panel;

		// literal obj represents a Panel
		this[name] = panel;

		// if there's already an active panel, deactivate the rest
		if (this.active){
			panel.deactivate();
		} else {
			// if no active panel, activate it
			panel.activate();
		}

		this.panels.push(panel);

		this.tabs.append_view(tab, name);

		this.append_view_ && this.append_view_(view, name);
	}
});

var Panel = View.extend({
	name: "Panel",
	link: function(view){
		view.click(function(){
			this.activate();
		}.bind(this));
	},
	activate: function(){
		this.panels.active.deactivate();
		this.show();
	},
	deactivate: function(){
		this.hide();
	}
});

// var Treeport = module.exports = View.extend({
// 	name: "Treeport",
// 	initialize: function(){
// 		this.list = List();
// 		this.list.tree = this;

// 		this.render();
// 		this.update();
// 	},
// 	append_view_: function(view, name){
// 		if (view instanceof Panel){
// 			this.tabs.add(name, view);
// 		}
// 	},
// 	tab: function(name, panel){
// 		this.tabs.append_prop()
// 	}
// 	render: function(){
// 		this.append(this.list);
// 		this.append(View(".content"));
// 	}
// });

/*
The treeport is basically vertical tabs
And, it can just as easily be horizontal tabs...

panels
	tabs
		tab1
		tab2
	container
		panel1
		panel2

If tabs and container are columns, you have vertical tabs.
If tabs and container are horizontal, you have horizontal tabs...

Panels(panel, panel, panel)
panels.add(panel); --> different than append; this lets you route it

Each panel has a .link(view) module.
--> a function that takes a view, and upgrades it to a link
--> basically just...
	wraps it in an a.link (fallback for nojs)
	adds the javascript




*/